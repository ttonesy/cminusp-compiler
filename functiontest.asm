# MIPS CODE Generated by CS370 Compiler

.data


_L0: .asciiz		 "Enter first number: "
_L1: .asciiz		 "Enter second number: "
_L2: .asciiz		 "The larger of "
_L3: .asciiz		 " and "
_L4: .asciiz		 " is "
_L5: .asciiz		 "\n"
_L6: .asciiz		 "Enter a limit for sum of squares: "
_L7: .asciiz		 "The sum of squares up to "
_L8: .asciiz		 " is "
_L9: .asciiz		 "\n"

.align 2


.text

.globl main


max:			# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 20		# Activation Record carve out copy size of function
	sw $ra, ($a1)		# Store Return Adress
	sw $sp 4($a1) 		# Store the old Stack Pointer
	move $sp, $a1		# Make SP the current activation record


	sw $t0, 8($sp)		# store func params into formal params
	sw $t1, 12($sp)		# store func params into formal params


	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 16($sp)		# Expression store LHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 16($sp)		# Expression restore LHS from memory
	sgt $a0, $a0, $a1		# EXPR greater than
	beq $a0 $0 _L10		# IF branch to else part

			# The positive portion of if
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra		# return to caller
	j _L11		# IF s1 END
_L10:			# ELSE target

			# The negative portion of IF if there is an else
			# Otherwise just these lines
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra		# return to caller
_L11:			# end of if
	li $a0, 0		# RETURN has not specified value set to 0
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra		# return to caller

			# END OF FUNCTION

sum_of_squares:			# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 52		# Activation Record carve out copy size of function
	sw $ra, ($a1)		# Store Return Adress
	sw $sp 4($a1) 		# Store the old Stack Pointer
	move $sp, $a1		# Make SP the current activation record


	sw $t0, 8($sp)		# store func params into formal params


	li $a0, 0		# expression is constant
	sw $a0 20($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a1 20($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
	li $a0, 1		# expression is constant
	sw $a0 24($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a1 24($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
_L12:			# # WHILE TOP target
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 28($sp)		# Expression store LHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 28($sp)		# Expression restore LHS from memory
	add $a1, $a1, 1		# EXPR LE add one to do compare
	slt $a0, $a0, $a1		# EXPR LE
	beq $a0 $0 _L13		# WHILE branch out | beginning
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 36($sp)		# Expression store LHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 32($sp)		# Expression store LHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 32($sp)		# Expression restore LHS from memory
	mult $a0 $a1		# EXPR MULT
	mflo $a0		# EXPR mult
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 36($sp)		# Expression restore LHS from memory
	add $a0, $a0, $a1		# EXPR ADD
	sw $a0 40($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a1 40($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 44($sp)		# Expression store LHS temporarily
	li $a0, 1		# expression is constant
	move $a1, $a0		# right hand side needs to be a1
	lw $a0, 44($sp)		# Expression restore LHS from memory
	add $a0, $a0, $a1		# EXPR ADD
	sw $a0 48($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a1 48($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
	j _L12		# WHILE JUMP BACK | check
_L13:			# END OF WHILE | loop back
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra		# return to caller
	li $a0, 0		# RETURN has not specified value set to 0
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	jr $ra		# return to caller

			# END OF FUNCTION

main:			# function definition
	move $a1, $sp		# Activation Record carve out copy SP
	subi $a1 $a1 48		# Activation Record carve out copy size of function
	sw $ra, ($a1)		# Store Return Adress
	sw $sp 4($a1) 		# Store the old Stack Pointer
	move $sp, $a1		# Make SP the current activation record




	la $a0, _L0		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	li $v0, 5		# About to read a number
	syscall		# read in value, store in $v0
	sw $v0, ($a0)		# store read in value to memory


	la $a0, _L1		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	li $v0, 5		# About to read a number
	syscall		# read in value, store in $v0
	sw $v0, ($a0)		# store read in value to memory


			# Setting up Function Call
			# evaluate Function Parameters
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 32($sp)		# Store call Arg temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 28($sp)		# Store call Arg temporarily

			# place parameters into T registers

	lw $a0, 32($sp)		# pull out stored Arg
	move $t0, $a0		# move to $t0-$t8
	lw $a0, 28($sp)		# pull out stored Arg
	move $t1, $a0		# move to $t0-$t8

	jal max		# Call the function

	sw $a0 36($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a1 36($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
	la $a0, _L2		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 8		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	li $v0, 1		# About to print a number
	syscall		# call write number


	la $a0, _L3		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 12		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	li $v0, 1		# About to print a number
	syscall		# call write number


	la $a0, _L4		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 16		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	li $v0, 1		# About to print a number
	syscall		# call write number


	la $a0, _L5		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	la $a0, _L6		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 20		# 		# VAR local stack pointer plus offset
	li $v0, 5		# About to read a number
	syscall		# read in value, store in $v0
	sw $v0, ($a0)		# store read in value to memory


			# Setting up Function Call
			# evaluate Function Parameters
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 20		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	sw $a0, 40($sp)		# Store call Arg temporarily

			# place parameters into T registers

	lw $a0, 40($sp)		# pull out stored Arg
	move $t0, $a0		# move to $t0-$t8

	jal sum_of_squares		# Call the function

	sw $a0 44($sp)		# ASSIGN store RHS temporarily
	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 24		# 		# VAR local stack pointer plus offset
	lw $a1 44($sp)		# ASSIGN retrieve RHS
	sw $a1, ($a0)		# ASSIGN store RHS to LHS
	la $a0, _L7		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 20		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	li $v0, 1		# About to print a number
	syscall		# call write number


	la $a0, _L8		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	move $a0 $sp		# 		# VAR local make a copy of stackpointer
	addi $a0 $a0 24		# 		# VAR local stack pointer plus offset
	lw $a0, ($a0)		# expression is a Var
	li $v0, 1		# About to print a number
	syscall		# call write number


	la $a0, _L9		# The string adress
	li $v0, 4		# About to print a string
	syscall		# call write string

	li $a0, 0		# RETURN has not specified value set to 0
	lw $ra ($sp)		# restore old environement RA
	lw $sp 4($sp)		# Return from function store SP

	li $v0, 10		# EXIT from main we are done
	syscall		# EXIT everything

			# END OF FUNCTION

