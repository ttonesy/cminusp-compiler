/*
	I would like to be graded at level e

	emit.c

	Antonio Luna
	Lab 9 | CS 370 | YACC
	5/1/2024

	This file produces MIPS code for my CS370 compiler for our simple CMINUS+ language.
	It utilizes information from our LEX, YACC, symbol table, and AST to generate the MIPS code.
	This file reads in a .c file with CMINUS+ code and outputs a .asm file with working MIPS code
	that can be run on a MIPS simulator.

*/

#include <string.h>
#include <stdlib.h>

#include "ast.h"
#include "emit.h"


// Internal prototypes
void emit_function(ASTnode* p, FILE* fp);
void emit_write(ASTnode* p, FILE* fp);
void emit_var(ASTnode* p, FILE* fp);
void emit_expr(ASTnode* p, FILE* fp);
void emit_assign(ASTnode* p, FILE* fp);
void emit_read(ASTnode* p, FILE* fp);
void emit_if(ASTnode* p, FILE* fp);
void emit_while(ASTnode* p, FILE* fp);
void emit_return(ASTnode* p, FILE* fp);
void emit_call(ASTnode* p, FILE* fp);


char* functionname = NULL; // global variable to store the function name for return


// PRE: PTR to AST, PTR file
// POST: prints out MIPS code into file, using helper functions

void EMIT(ASTnode* p, FILE* fp)
{
	// This function will emit the MIPS code for the AST
	if (p == NULL) return;
	if (fp == NULL) return;

	fprintf(fp, "# MIPS CODE Generated by CS370 Compiler\n\n");
	fprintf(fp, ".data\n\n\n");

	EMIT_STRINGS(p, fp);
	fprintf(fp, "\n.align 2\n\n");

	EMIT_GLOBALS(p, fp);
	fprintf(fp, "\n.text\n\n");

	fprintf(fp, ".globl main\n\n\n");

	EMIT_AST(p, fp);

} // end of EMIT


// PRE: nothing
// POST: returns a new label for use in MIPS code

void emit(FILE* fp, char* label, char* command, char* comment)
{
	if (strcmp("", comment) == 0)
		if (strcmp("", label) == 0)
			fprintf(fp, "\t%s\t\t\n", command);
		else
			fprintf(fp, "%s:\t%s\t\t\n", label, command);
	else
		if (strcmp("", label) == 0)
			fprintf(fp, "\t%s\t\t# %s\n", command, comment);
		else
			fprintf(fp, "%s:\t%s\t\t# %s\n", label, command, comment);

} // end of emit


// PRE:  PTR to top of AST, and FILE ptr to print to 
// POST:  prints MIPS based  global variables into file 

void EMIT_GLOBALS(ASTnode* p, FILE* fp)
{
	if (p == NULL) return;

	// check if we are at a global variable
	if (p->type == A_VARDEC && p->symbol->level == 0)
	{
		fprintf(fp, "%s: .space %d		#global variables\n", p->name, p->symbol->mysize * WSIZE);
	}

	EMIT_GLOBALS(p->s1, fp);
	EMIT_GLOBALS(p->next, fp);

} // end of EMIT_GLOBALS


// PRE:  PTR to top of AST, and FILE ptr to print to 
// POST:  Adds a label into the AST for use string in write statements 

void EMIT_STRINGS(ASTnode* p, FILE* fp)
{
	// use p->label
	if (p == NULL) return;

	// check if we are at a string
	if (p->type == A_WRITE && p->name != NULL)
	{
		p->label = CreateLabel();
		fprintf(fp, "%s: .asciiz		 %s\n", p->label, p->name);
	}

	EMIT_STRINGS(p->next, fp);
	EMIT_STRINGS(p->s1, fp);
	EMIT_STRINGS(p->s2, fp);

} // end of EMIT_STRINGS


// PRE: PTR TO ASTnode A_FUNCTIONDEC
// POST: MIBS code in fp

void emit_function(ASTnode* p, FILE* fp)
{
	char s[100];

	// set function name to current function
	functionname = p->name;

	emit(fp, p->name, "", "function definition");

	// carve out space for the activation record
	emit(fp, "", "move $a1, $sp", "Activation Record carve out copy SP");
	sprintf(s, "subi $a1 $a1 %d", p->symbol->offset * WSIZE);
	emit(fp, "", s, "Activation Record carve out copy size of function");
	emit(fp, "", "sw $ra, ($a1)", "Store Return Adress");
	sprintf(s, "sw $sp %d($a1) ", WSIZE);
	emit(fp, "", s, "Store the old Stack Pointer");
	emit(fp, "", "move $sp, $a1", "Make SP the current activation record");
	fprintf(fp, "\n\n");

	// store the parameters into the activation record
	ASTnode* t = p->symbol->fparms;
	int x = 0;
	while (t != NULL)
	{
		sprintf(s, "sw $t%d, %d($sp)", x, t->symbol->offset * WSIZE);
		emit(fp, "", s, "store func params into formal params");
		t = t->next;
		x++;

	} // end of while

	fprintf(fp, "\n\n");

	// generate the compound statement
	EMIT_AST(p->s2, fp);

	// restore RA and SP before we return
	emit(fp, "", "li $a0, 0", "RETURN has not specified value set to 0");
	emit(fp, "", "lw $ra ($sp)", "restore old environement RA");
	sprintf(s, "lw $sp %d($sp)", WSIZE);
	emit(fp, "", s, "Return from function store SP");
	fprintf(fp, "\n");

	// check if we are in for exit system syscall
	if (strcmp(p->name, "main") == 0)
	{
		// exit the system
		emit(fp, "", "li $v0, 10", "EXIT from main we are done");
		emit(fp, "", "syscall", "EXIT everything");
	}
	else
	{
		// jump back to the caller
		emit(fp, "", "jr $ra", "return to caller");
	}

	fprintf(fp, "\n\t\t\t# END OF FUNCTION\n\n");

} // end of emit_function


// PRE: PTR to A_WRITE
// POST: MIPS code to generate WRITE string or write a number depending
// on our arguments

void emit_write(ASTnode* p, FILE* fp)
{
	char s[100];

	// check if the name is null, if it is not then it is a string
	if (p->name != NULL)
	{
		// need to load the adress of label into $a0
		// and call print string
		sprintf(s, "la $a0, %s", p->label);
		emit(fp, "", s, "The string adress");
		emit(fp, "", "li $v0, 4", "About to print a string");
		emit(fp, "", "syscall", "call write string");
		fprintf(fp, "\n");
	}
	else
	{
		// if we are here it is an epression
		emit_expr(p->s1, fp); // now $a0 has the expression value
		emit(fp, "", "li $v0, 1", "About to print a number");
		emit(fp, "", "syscall", "call write number");
		fprintf(fp, "\n\n");
	}

} // end of emit_write


// PRE: PTR to A_VAR
// POST: MIPS code to load the adress of the variable into $a0

void emit_var(ASTnode* p, FILE* fp)
{
	char s[100];

	// check if it is an array or not
	if (p->s1 != NULL)
	{
		emit_expr(p->s1, fp);
		emit(fp, "", "move $a1, $a0", "\t\t# VAR copy index array in a1");
		emit(fp, "", "sll $a1 $a1 2", "\t\t# muliply the index by wordszie via SLL");
	}

	// check if it is a global variable
	if (p->symbol->level == 0)
	{
		//get the direct address of Global Var
		sprintf(s, "la $a0, %s", p->name);
		emit(fp, "", s, "\t\t# EMIT Var global variable");
	}
	else {
		//local variable Stack pointer plus offset
		emit(fp, "", "move $a0 $sp", "\t\t# VAR local make a copy of stackpointer");
		sprintf(s, "addi $a0 $a0 %d", p->symbol->offset * WSIZE);
		emit(fp, "", s, "\t\t# VAR local stack pointer plus offset");
	}

	//add on array index
	if (p->s1 != NULL)
	{
		emit(fp, "", "add $a0 $a0 $a1", "\t\t# VAR array add internal offset");
	}

} // end of emit_var


// PRE: PTR to expression family
// POST: MIPS code that sets $a0 to the value of the expression

void emit_expr(ASTnode* p, FILE* fp)
{
	char s[100];

	// base case
	switch (p->type)
	{
	case A_NUM:
		sprintf(s, "li $a0, %d", p->value);
		emit(fp, "", s, "expression is constant");
		return;
		break;

	case A_EXPR:
		break;

	case A_VAR:
		emit_var(p, fp); // $a0 is the memory location
		emit(fp, "", "lw $a0, ($a0)", "expression is a Var");
		return;
		break;

	case A_CALL:
		emit_call(p, fp);
		return;
		break;

	case A_EXPRSTMT:
		emit_call(p, fp);
		return;
		break;

	default:
		printf("emit expr switch NEVER SHOULD BE HERE\n");
		printf("FIX FIX FIX\n");
		exit(1);

	} // end of switch


	// print this everytime to store the LHS into memory
	emit_expr(p->s1, fp);
	sprintf(s, "sw $a0, %d($sp)", p->symbol->offset * WSIZE);
	emit(fp, "", s, "Expression store LHS temporarily");

	// check if we are in A_UNARY or not
	if (p->s2 != NULL)
	{
		emit_expr(p->s2, fp);
		emit(fp, "", "move $a1, $a0", "right hand side needs to be a1");
		sprintf(s, "lw $a0, %d($sp)", p->symbol->offset * WSIZE);
		emit(fp, "", s, "Expression restore LHS from memory");

		switch (p->operator)
		{
		case A_PLUS:
			emit(fp, "", "add $a0, $a0, $a1", "EXPR ADD");
			break;

		case A_MINUS:
			emit(fp, "", "sub $a0, $a0, $a1", "EXPR MINUS");
			break;

		case A_MULT:
			emit(fp, "", "mult $a0 $a1", "EXPR MULT");
			emit(fp, "", "mflo $a0", "EXPR mult");
			break;

		case A_DIV:
			emit(fp, "", "div $a0, $a0, $a1", "EXPR divide");
			break;

		case A_MOD:
			emit(fp, "", "div $a0 $a1", "EXPR DIV remainder");
			emit(fp, "", "mfhi $a0", "store remainder");
			break;

		case A_LT:
			emit(fp, "", "slt $a0, $a0, $a1", "EXPR less than");
			break;

		case A_LE:
			emit(fp, "", "add $a1, $a1, 1", "EXPR LE add one to do compare");
			emit(fp, "", "slt $a0, $a0, $a1", "EXPR LE");
			break;

		case A_GT:
			emit(fp, "", "sgt $a0, $a0, $a1", "EXPR greater than");
			break;

		case A_GE:
			emit(fp, "", "add $a0, $a0, 1", "EXPR GE add one to do compare");
			emit(fp, "", "slt $a0, $a1, $a0", "EXPR GE");
			break;

		case A_EQ:
			emit(fp, "", "seq $a0, $a0, $a1", "EXPR equal");
			break;

		case A_NE:
			emit(fp, "", "sne $a0, $a0, $a1", "EXPR not equal");
			break;

		} // end of switch

	} // end of if

	else // assume if p->s2 is NULL we are in A_UNARY
	{
		emit(fp, "", "move $a1 $a0", "UNARY minus copy into $a1");
		emit(fp, "", "li $a0 0", "set $a0 as 0");
		emit(fp, "", "sub $a0, $a0, $a1", "subtract the value by 0 to make it negative");
	}

} // end of emit_expr


// PRE: PTR to A_ASSIGNMENT
// POST: MIPS code to assign the value of the expression to the variable

void emit_assign(ASTnode* p, FILE* fp)
{
	// this function will emit the expression of assign
	// store it temporarily
	// emit the left hand side into $a0
	// retrieve stored value into $a1
	// store $a1 into ($a0)
	char s[100];

	emit_expr(p->s2, fp);
	sprintf(s, "sw $a0 %d($sp)", p->symbol->offset * WSIZE);
	emit(fp, "", s, "ASSIGN store RHS temporarily");

	emit_var(p->s1, fp);
	sprintf(s, "lw $a1 %d($sp)", p->symbol->offset * WSIZE);
	emit(fp, "", s, "ASSIGN retrieve RHS");
	emit(fp, "", "sw $a1, ($a0)", "ASSIGN store RHS to LHS");

} // end of emit_assign	


//PRE: PTR to A_Read
//POST: MIPS code to read in a number and place in VAR of a read statement

void emit_read(ASTnode* p, FILE* fp)
{
	// call the helper function to get the address of the variable
	emit_var(p->s1, fp); // now $a0 has the expression value
	emit(fp, "", "li $v0, 5", "About to read a number");
	emit(fp, "", "syscall", "read in value, store in $v0");
	emit(fp, "", "sw $v0, ($a0)", "store read in value to memory");
	fprintf(fp, "\n\n");

} // end of emit_var


// PRE: PTR to A_IF
// POST: MIPS code to generate an if else statement

void emit_if(ASTnode* p, FILE* fp)
{
	char s[100];
	char* L1 = CreateLabel();
	char* L2 = CreateLabel();

	emit_expr(p->s1, fp); // call emit_expr on the expression

	sprintf(s, "beq $a0 $0 %s", L1);
	emit(fp, "", s, "IF branch to else part\n");
	emit(fp, "", "", "The positive portion of if");

	EMIT_AST(p->s2->s1, fp);

	sprintf(s, "j %s", L2);
	emit(fp, "", s, "IF s1 END");

	emit(fp, L1, "", "ELSE target\n");
	emit(fp, "", "", "The negative portion of IF if there is an else");
	emit(fp, "", "", "Otherwise just these lines");

	// check if we have an else statement
	if (p->s2->s2 != NULL)
	{
		EMIT_AST(p->s2->s2, fp);
	}
	emit(fp, L2, "", "end of if");

} // end of emit_if


// PRE: PTR to A_WHILE
// POST: MIPS code to generate a while loop

void emit_while(ASTnode* p, FILE* fp)
{
	char s[100];
	char* L1 = CreateLabel(); // label for the top of the loop
	char* L2 = CreateLabel(); // label for the end of the loop

	emit(fp, L1, "", "# WHILE TOP target");

	emit_expr(p->s1, fp); // call emit_expr on the expression portion
	sprintf(s, "beq $a0 $0 %s", L2);
	emit(fp, "", s, "WHILE branch out | beginning");

	EMIT_AST(p->s2, fp); // generate the compound statement
	sprintf(s, "j %s", L1);
	emit(fp, "", s, "WHILE JUMP BACK | check");

	emit(fp, L2, "", "END OF WHILE | loop back");

} // end of emit_while


// PRE: PTR to A_RETURN
// POST: MIPS code to generate a return statement

void emit_return(ASTnode* p, FILE* fp)
{
	char s[100];

	// check if we have a return value
	if (p->s1 != NULL)
	{
		emit_expr(p->s1, fp);
	}
	else
	{
		emit(fp, "", "li $a0, 0", "RETURN has no specified value set to 0");
	}

	// restore RA and SP before we return
	emit(fp, "", "lw $ra ($sp)", "restore old environement RA");
	sprintf(s, "lw $sp %d($sp)", WSIZE);
	emit(fp, "", s, "Return from function store SP");
	fprintf(fp, "\n");

	// check if we are in main for exit system syscall
	if (strcmp(functionname, "main") == 0)
	{
		// exit the system
		emit(fp, "", "li $v0, 10", "Exit from main we are done");
		emit(fp, "", "syscall\t", "EXIT everything");
	}
	else
	{
		// jump back to the caller
		emit(fp, "", "jr $ra", "return to caller");
	}

} // end of return


// PRE: PTR to A_CALL
// POST: MIPS code to generate a function call

void emit_call(ASTnode* p, FILE* fp)
{
	char s[100];

	emit(fp, "", "", "Setting up Function Call");
	emit(fp, "", "", "evaluate Function Parameters");

	// evaluate the arguments and store temporarily in $t0-$t8
	ASTnode* a = p->s1;

	// store the arguments in the activation record
	for (int i = 0; i < 7; i++)
	{
		if (a == NULL) break;
		emit_expr(a->s1, fp);
		sprintf(s, "sw $a0, %d($sp)", a->symbol->offset * WSIZE);
		emit(fp, "", s, "Store call Arg temporarily");
		a = a->next;

	} // end of for

	fprintf(fp, "\n");
	emit(fp, "", "", "place parameters into T registers\n");

	a = p->s1;

	// load the arguments into $a0-$a7
	for (int i = 0; i < 7; i++)
	{
		if (a == NULL) break;
		sprintf(s, "lw $a0, %d($sp)", a->symbol->offset * WSIZE);
		emit(fp, "", s, "pull out stored Arg");
		sprintf(s, "move $t%d, $a0", i);
		emit(fp, "", s, "move to $t0-$t8");
		a = a->next;

	} // end of for

	fprintf(fp, "\n");
	sprintf(s, "jal %s", p->name);
	emit(fp, "", s, "Call the function\n");

} // end of emit_call


// PRE: PTR to ASTnode or NULL
// POST: MIPS code into the file for the tree

void EMIT_AST(ASTnode* p, FILE* fp)
{
	if (p == NULL) return;

	switch (p->type)
	{

	case A_VARDEC: // no real action
		EMIT_AST(p->next, fp);
		break;

	case A_FUNCTIONDEC:
		emit_function(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_WRITE:
		// deal with using helper function
		emit_write(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_READ:
		emit_read(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_COMPOUND:
		// no action for s1 vardec already in stack size
		EMIT_AST(p->s2, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_ASSIGNMENT:
		emit_assign(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_IF:
		emit_if(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_WHILE:
		emit_while(p, fp);
		EMIT_AST(p->next, fp);
		break;

	case A_RETURN:
		emit_return(p, fp);
		EMIT_AST(p->next, fp);
		break;

		// deal with function calls WITHOUT arguments
	case A_EXPRSTMT:
		emit_expr(p->s1, fp);
		EMIT_AST(p->next, fp);
		break;

	default:
		printf("\nEMIT_AST case %d not implemented \n", p->type);
		printf("WE SHOULD NEVER BE HERE\n");
		exit(1);

	} // end of switch

} // end of EMIT_AST